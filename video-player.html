<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../materializecss-styles/materializecss-styles.html">
<link rel="import" href="../hax-body-behaviors/hax-body-behaviors.html">

<!--
`video-player`
A simple responsive video player

@demo demo/index.html

@microcopy - the mental model for this element
 - video source - url / link to the video file

-->

<dom-module id="video-player">
  <template>
    <style include="materializecss-styles">
      :host {
        display: block;
      }
      :host[responsive] .responsive-video-container {
        position: relative;
        padding-bottom: 56.25%; /* 16:9 */
        padding-top: 25px;
        height: 0;
      }
      :host[responsive] .responsive-video-container iframe {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      :host[responsive] .responsive-video-container video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      .video-caption {
        font-style: italic;
        margin: 0;
        padding: 0;
        @apply --video-player-caption-theme;
      }
    </style>
    <div class="responsive-video-container">
      <template is="dom-if" if="[[iframed]]">
        <iframe src="[[src]]" width="[[width]]" height="[[height]]" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
      </template>
      <template is="dom-if" if="[[!iframed]]">
        <video src="[[src]]" width="[[width]]" height="[[height]]" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen controls></video>
      </template>
    </div>
    <div id="videocaption" class$="video-caption [[secondaryColorClass]]">
      [[caption]]
    </div>
    <div id="captionslot" class$="video-caption [[secondaryColorClass]]">
      <slot name="caption"></slot>
    </div>
  </template>

  <script>
    Polymer({
      is: 'video-player',
      behaviors: [HAXBehaviors.PropertiesBehaviors, MaterializeCSSBehaviors.ColorBehaviors],
      properties: {
        /**
         * Source of the video
         */
        source: {
          type: String,
          reflectToAttribute: true,
        },
        /**
         * Computed / cleaned up source.
         */
        src: {
          type: String,
          computed: '_computeSRC(source)',
        },
        /**
         * Computesd if this should be iframed or not.
         */
        iframed: {
          type: Boolean,
          computed: '_computeIframed(source)',
        },
        /**
         * Video width
         */
        width: {
          type: String,
          value: 560,
        },
        /**
         * video height
         */
        height: {
          type: String,
          value: 315,
        },
        /**
         * Responsive video, calculated from not-responsive.
         */
        responsive: {
          type: Boolean,
          reflectToAttribute: true,
          value: true,
        },
        /**
         * Simple caption for the video
         */
        caption: {
          type: String,
          reflectToAttribute: true,
        },
        /**
         * Primary Color.
         */
        primaryColor: {
          type: String,
          value: null,
          reflectToAttribute: true,
          observer: '_primaryColorChanged',
        },
        /**
         * Secondary Color.
         */
        secondaryColor: {
          type: String,
          value: null,
          reflectToAttribute: true,
        },
        /**
         * Primary color class.
         */
        primaryColorClass: {
          type: String,
          reflectToAttribute: true,
          computed: '_computeColorClass(primaryColor)',
        },
        /**
         * Secondary color class.
         */
        secondaryColorClass: {
          type: String,
          reflectToAttribute: true,
          computed: '_computeColorClass(secondaryColor)',
        },
        /**
         * Simple video styles for consistent presentation.
         */
        videoStyle: {
          type: String,
          value: 'style1',
          reflectToAttribute: true,
        },
        /**
         * Youtube cookie-less domain for privacy.
         */
        ytNocookie: {
          type: Boolean,
          value: true,
        },
        /**
         * Youtube suggested option.
         */
        ytSuggested: {
          type: Boolean,
          value: false,
        },
        /**
         * Youtube controls option.
         */
        ytControls: {
          type: Boolean,
          value: true,
        },
        /**
         * Youtube title option.
         */
        ytTitle: {
          type: Boolean,
          value: false,
        },
        /**
         * Vimeo option for title being displayed.
         */
        vimeoTitle: {
          type: Boolean,
          value: false,
        },
        /**
         * Vimeo option for author being displayed.
         */
        vimeoByline: {
          type: Boolean,
          value: false,
        },
        /**
         * Vimeo option for portrait mode.
         */
        vimeoPortrait: {
          type: Boolean,
          value: false,
        },
        /**
         * Vimeo option for color.
         */
        vimeoColor: {
          type: String,
          value: 'FF031D',
        },
      },
      /**
       * Ready.
       */
      ready: function() {
        // Establish hax properties if they exist
        let props = {
          'canScale': true,
          'canPosition': true,
          'settings': [
            {
              'property': 'source',
              'title': 'Source',
              'description': 'The URL for this video.',
              'inputMethod': 'textfield',
              'type': 'bar',
              'icon': 'link',
              'required': true,
              'validationType': 'url',
            },
            {
              'property': 'caption',
              'title': 'caption',
              'description': 'Simple caption for under video',
              'inputMethod': 'textfield',
              'type': 'bar',
              'icon': 'av:video-label',
              'required': false,
              'validationType': 'text',
            },
            {
              'property': 'responsive',
              'title': 'Responsive',
              'description': 'The video automatically fills the available area.',
              'inputMethod': 'boolean',
              'type': 'bar',
              'icon': 'image:photo-size-select-small',
            },
            {
              'property': 'primaryColor',
              'title': 'Primary color',
              'description': 'Select the primary color used in the video',
              'inputMethod': 'colorpicker',
              'type': 'bar',
              'icon': 'editor:format-color-fill',
            },
            {
              'property': 'secondaryColor',
              'title': 'Secondary color',
              'description': 'Select the secondary color used for the video',
              'inputMethod': 'colorpicker',
              'type': 'bar',
              'icon': 'editor:format-color-fill',
            },
            {
              'property': 'videoStyle',
              'title': 'Style',
              'description': 'Simple video presentation style.',
              'inputMethod': 'select',
              'options': {
                'style1': 'Style 1',
                'style2': 'Style 2',
              },
              'type': 'bar',
              'icon': 'av:subscriptions',
            },
          ]
        };
        this.setHaxProperties(props);
      },
      /**
       * Compute src from type / source combo.
       * Type is set by source so this ensures a waterfall
       * of valid values.
       */
      _computeSRC: function(source) {
        if (typeof source !== typeof undefined) {
          let type = this.getType(source);
          // ensure that this is a valid url / cleaned up a bit
          source = this.cleanSource(source, type);
          if (type == 'vimeo') {
            if (this.vimeoTitle) {
              source += '?title=1';
            }
            else {
              source += '?title=0';
            }
            if (this.vimeoByline) {
              source += '&byline=1';
            }
            else {
              source += '&byline=0';
            }
            if (this.vimeoPortrait) {
              source += '&portrait=1';
            }
            else {
              source += '&portrait=0';
            }
            if (typeof this.vimeoColor !== typeof undefined) {
              source += '&color=' + this.vimeoColor;
            }
          }
          else if (type == 'youtube') {
            // ensure options are applied to the address
            if (this.ytNocookie) {
              source = source.replace('youtube.com/embed', 'youtube-nocookie.com/embed');
            }
            if (this.ytTitle) {
              source += '?showinfo=1';
            }
            else {
              source += '?showinfo=0';
            }
            if (this.ytControls) {
              source += '&controls=1';
            }
            else {
              source += '&controls=0';
            }
            if (this.ytSuggested) {
              source += '&rel=1';
            }
            else {
              source += '&rel=0';
            }
          }
        }
        return source;
      },
      /**
       * Primary color changed, spread into internals.
       */
      _primaryColorChanged: function(newValue, oldValue) {
        if (newValue != null) {
          this.vimeoColor = newValue.substring(1);
          // aggressive rebuild of source so vimeo picks up
          // the color change and updates the URL to match
          if (this.getType(this.source) == 'vimeo') {
            var source = this.source;
            this.set('source', '');
            this.set('source', source);
          }
        }
      },
      /**
       * Make class from color value
       */
      _computeColorClass: function(color) {
        if (color != null && color.substring(0, 1) == '#') {
          return this._colorTransform(color, '', '');
        }
      },
      /**
       * Compute iframe or video tag for implementation.
       */
      _computeIframed: function(source) {
        let type = this.getType(source);
        if (type == 'youtube' || type == 'vimeo' || type == 'external') {
          return true;
        }
        else {
          return false;
        }
      },
      /**
       * Check source of the video, potentially correcting bad links.
       */
      cleanSource: function(input, type) {
        if (type == 'vimeo' || type == 'youtube') {
          // strip off the ? modifier for youtube/vimeo so we can build ourselves
          var tmp = input.split('?');
          var v = '';
          input = tmp[0];
          if (tmp.length == 2) {
            args = tmp[1].split('=');
            if (args[0] == 'v') {
              v = args[1];
            }
          }
          // link to the vimeo video instead of the embed player address
          if (input.indexOf('player.vimeo.com') == -1 && input.indexOf('vimeo.com') != -1) {
            return input.replace('vimeo.com/', 'player.vimeo.com/video/');
          }
          // copy and paste from the URL
          else if (input.indexOf('youtube.com/watch') != -1) {
            return input.replace('youtube.com/watch', 'youtube.com/embed/') + v;
          }
          // weird share-ly style version
          else if (input.indexOf('youtu.be') != -1) {
            return input.replace('youtu.be/', 'www.youtube.com/embed/') + v;
          }
        }
        return input;
      },
      /**
       * Figure out the type of video based on source.
       */
      getType: function(source) {
        if (source.indexOf('vimeo') != -1) {
          return 'vimeo';
        }
        else if (source.indexOf('youtube') != -1 || source.indexOf('youtu.be') != -1) {
          return 'youtube';

        }
        return 'local';
      },
    });
  </script>
</dom-module>
